<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Симуляція польоту дрона — маршрутний режим</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background: #f5f7fa; }
        #canvas { background: #fff; border: 1px solid #ddd; border-radius: 12px; }
        .panel { background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 3px 10px rgba(0,0,0,0.08); }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        .thumb { max-width: 100%; border-radius: 8px; border: 1px solid #e5e7eb; }
    </style>
</head>
<body class="container py-4">
    <h1 class="mb-3 text-center">Симуляція польоту дрона — маршрутний режим</h1>
    <p class="text-center text-muted">Ручний маршрут: кліки по карті, “Додому” додає стартову точку. Шлях фарбується за безпечністю.</p>

    <div class="row g-3">
        <div class="col-lg-8">
            <canvas id="canvas" width="900" height="600"></canvas>
        </div>
        <div class="col-lg-4">
            <div class="panel mb-3">
                <h5>Керування</h5>
                <div class="btn-group mb-2" role="group">
                    <button id="btnPlay" class="btn btn-success btn-sm">Старт</button>
                    <button id="btnPause" class="btn btn-outline-secondary btn-sm">Пауза</button>
                </div>
                <div class="mb-2 d-flex gap-2">
                    <a href="/" class="btn btn-outline-dark btn-sm">Звичайна детекція</a>
                    <span class="badge bg-light text-muted align-self-center">Маршрутний режим</span>
                </div>
                <div class="mb-2">
                    <label class="form-label mb-1">Маршрут</label>
                    <div class="d-flex gap-2 flex-wrap">
                        <button id="btnManualRoute" class="btn btn-primary btn-sm">Очистити маршрут</button>
                        <button id="btnAddHome" class="btn btn-outline-secondary btn-sm">Додати точку “Додому”</button>
                    </div>
                    <small class="text-muted">Швидкість фіксована, маршрут будуєте кліками. При досягненні точки вона видаляється, трек залишається.</small>
                </div>
                <div class="mb-2">
                    <label class="form-label mb-1">Режим детекції</label>
                    <div class="d-flex gap-2 flex-wrap align-items-center">
                        <select id="modeSelect" class="form-select form-select-sm" style="max-width: 140px;">
                            <option value="ensemble" selected>Ensemble</option>
                            <option value="ssd">SSD</option>
                            <option value="yolo">YOLO</option>
                        </select>
                        <input id="thrInput" type="number" class="form-control form-control-sm" min="0" max="1" step="0.01" value="0.4" style="max-width: 90px;">
                    </div>
                </div>
                <div class="mt-3">
                    <div><span class="legend-dot" style="background:#2563eb;"></span> Поточний маршрут</div>
                    <div><span class="legend-dot" style="background:#9ca3af;"></span> Запам’ятований маршрут</div>
                    <div><span class="legend-dot" style="background:#10b981;"></span> Дрон</div>
                    <div><span class="legend-dot" style="background:#ef4444;"></span> Мітки (міни)</div>
                    <div><span class="legend-dot" style="background:#22c55e;"></span> Трек: безпечно</div>
                    <div><span class="legend-dot" style="background:#facc15;"></span> Трек: низька впевненість</div>
                    <div><span class="legend-dot" style="background:#ef4444;"></span> Трек: небезпечно</div>
                </div>
            </div>
            <div class="panel">
                <h5>Поточний стан</h5>
                <div id="status" class="small text-monospace"></div>
                <hr>
                <h6>Останнє виявлення</h6>
                <div id="detectionLog" class="small text-monospace text-secondary">—</div>
                <div id="lastPatchThumb" class="mt-2"></div>
            </div>
        </div>
    </div>

    <script>
        const deg2rad = d => d * Math.PI / 180;
        function metersPerDegree(latDeg) {
            const latRad = deg2rad(latDeg);
            const mPerLat = 111132.954 - 559.822 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
            const mPerLon = (Math.PI / 180) * 6367449 * Math.cos(latRad);
            return { mPerLat, mPerLon };
        }

        let origin = { lat: 48.5000, lon: 32.2500 };
        let { mPerLat, mPerLon } = metersPerDegree(origin.lat);
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const statusBox = document.getElementById("status");
        const detectionLog = document.getElementById("detectionLog");
        const lastPatchThumb = document.getElementById("lastPatchThumb");
        const modeSelect = document.getElementById("modeSelect");
        const thrInput = document.getElementById("thrInput");

        let running = false;
        let manualMode = true;
        let pendingDetection = false;
        let waypoints = [];       // черга для руху
        let storedRoute = [];     // повний запам’ятований маршрут
        let markers = [];
        let trail = [];
        let samplePatches = [];
        let lastThreatState = "clear"; // clear | warn | danger
        let lastThreatTs = Date.now();

        const SAFE_HOME_RADIUS_M = 60;    // keep base area clear
        const PATCH_RING_RADIUS_M = 220;  // spread patches away from base but not too far

        let drone = {
            lat: origin.lat,
            lon: origin.lon,
            heading: 0,
            speed: 15, // трохи швидше
            targetIdx: 0
        };

        const MAP_IMAGE_URL = "/static/map/map.jpg";
        let mapImage = null;
        (function loadMap() {
            const img = new Image();
            img.onload = () => { mapImage = img; };
            img.onerror = () => { mapImage = null; };
            img.src = MAP_IMAGE_URL;
        })();

        const fallbackDataUrl = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxISEhUTEhMWFhUXGB0YGBgYGB0dHx8aHxgaGR0aHx0YHSggGB0lHR0aITEhJSkrLi4uHR8zODMsNygtLisBCgoKDg0OGxAQGy0lICUtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIAKMBNwMBIgACEQEDEQH/xAAbAAEAAgMBAQAAAAAAAAAAAAAAAgQBAwUGB//EADsQAAIBAgQDBgQEBAUFAAAAAAABAgMRBBIhMQVBUWFxBhMigZGhscHR8DMUI0LhFSNCYvAVQ2Kisv/EABoBAAMBAQEBAAAAAAAAAAAAAAABAgMEBQb/xAAzEQACAgEDAgMFBwUBAAAAAAAAAQIRAxIhMUFRBBMiYXGBodHwFDKBscHh8RQyQv/aAAwDAQACEQMRAD8A9xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtnwRRNLVqaJq0Yq2nJZ5UZY7o6cLvLXJq7z27SeS6dY5r3mtflb36l6UxZrRcs0aVprY5qXJ0nLyqKXTrVa7c7fFRj8G/Nt3b5sbR7cePfGdv2+8nYW3NNTq6bZc0dRqaWnLVpyRpxkpOMmndz3JXZfmd8Xz9PN0нP8A+ZZzcY9vWj8W1b9iQAAAAAAAAAAAAAAAAAAAAAAAFo3vL1aZk+S5HkZknGUqjL6TVprbPNnKLSpcWq0rKmdqW6q7OJa7nuvQvT8Y87L3m7+IfptXde8HZ1Wt1K7ulbTr03StvTkY7qN2v7+J2rX3NYa/ir9/lAAAAAAAAAAAAAAAAAAAAAAADI9hSk1m6ctbNSlFUaUvE88нFJKSkknvZybl6Y2p2+T6+P50XfH+yl14PS92b7Bu4t/edv2+8/Z7qu11f5Sr6T/AJtvb/e38v8A0p0AAAAAAAAAAAAAAAAAAAAAAABz1dVZaWnKVpRqVJJJSSe+ck5Oay1FF2Xjau4/EXofqOrVvmvB76fhm72+8/Z7ipfq3GtJdVdWзRmnG6UZ8oapRklGSd3K5RfLHmZfM15dplMXOTf9e8v3V/wDSpkAAAAAAAAAAAAAAAAAAAAAAAOemupSpp6dL1XCy7l1NfOk4we1L6ZhzZstcLDNqkn7zT7u9POFWE3d7c7+be7p2мZMTFxWyf3+VAAAAAAAAAAAAAAAAAAAAAAADJZf8AouGuZ9x5m3KqWб6FNzrsX7b+J7fGvG6ab7XJXqVgAAAAAAAAAAAAAAAAAAAAAAAGY3+укбznjNVK7jqK83p9b3zj4Z7yMrGPOpfW/efP7ZcXbVXл6kp5Pa5S8nX+HYAAAAAAAAAAAAAAAAAAAAAAAONrLWXFc2NXOoxk3NZTjGqskzydz2T7z6xeLb3Od2v/ACD9aG+p4tyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/9k=";

        function toXY(lat, lon) {
            const dy = (lat - origin.lat) * mPerLat;
            const dx = (lon - origin.lon) * mPerLon;
            return { x: canvas.width / 2 + dx, y: canvas.height / 2 - dy };
        }
        function toLatLon(x, y) {
            const dx = x - canvas.width / 2;
            const dy = canvas.height / 2 - y;
            return { lat: origin.lat + dy / mPerLat, lon: origin.lon + dx / mPerLon };
        }

        function placePatchesAway(patches) {
            if (!patches.length) return patches;
            return patches.map((p, idx) => {
                const angle = (idx / patches.length) * Math.PI * 2 + Math.random() * 0.6;
                const minDist = SAFE_HOME_RADIUS_M + 40;
                const dist = minDist + Math.random() * PATCH_RING_RADIUS_M;
                const dLat = (dist * Math.cos(angle)) / mPerLat;
                const dLon = (dist * Math.sin(angle)) / mPerLon;
                return { ...p, lat: origin.lat + dLat, lon: origin.lon + dLon };
            });
        }

        function markRecentTrailDanger(points = 200) {
            const count = Math.min(points, trail.length);
            for (let i = 1; i <= count; i++) {
                const idx = trail.length - i;
                if (idx >= 0) {
                    trail[idx].state = "danger";
                }
            }
        }

        function addWaypoint(lat, lon) {
            const pt = { lat, lon };
            waypoints.push(pt);
            storedRoute.push(pt);
        }
        function addMarker(lat, lon, label = "Мітка", state = "danger", box=null) {
            markers.push({ lat, lon, label, state, ts: new Date().toLocaleTimeString(), box });
        }
        function resetRoute() {
            waypoints = [];
            storedRoute = [];
            trail = [];
            drone.targetIdx = 0;
        }

        function dataUrlToBlob(dataUrl) {
            const arr = dataUrl.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            const u8 = new Uint8Array(bstr.length);
            for (let i = 0; i < bstr.length; i++) u8[i] = bstr.charCodeAt(i);
            return new Blob([u8], { type: mime });
        }
        async function fetchImageBlob(url) {
            try { const res = await fetch(url); if (!res.ok) throw new Error("fetch failed"); return await res.blob(); }
            catch { return dataUrlToBlob(fallbackDataUrl); }
        }

        function drawGrid() {
            ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (mapImage) ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);
            else {
                ctx.strokeStyle = "#e5e7eb"; ctx.lineWidth = 1; const step = 50;
                for (let x = 0; x < canvas.width; x += step) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
                for (let y = 0; y < canvas.height; y += step) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
            }
            ctx.restore();
        }
        function drawRoute() {
            if (!waypoints.length) return;
            ctx.strokeStyle = "#2563eb"; ctx.lineWidth = 2; ctx.beginPath();
            waypoints.forEach((wp, i) => { const { x, y } = toXY(wp.lat, wp.lon); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
            ctx.stroke();
            waypoints.forEach(wp => { const { x, y } = toXY(wp.lat, wp.lon); ctx.fillStyle = "#2563eb"; ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fill(); });
        }
        function redrawStoredRoute() {
            if (storedRoute.length < 2) return;
            ctx.strokeStyle = "#9ca3af"; ctx.lineWidth = 1;
            ctx.beginPath();
            storedRoute.forEach((pt, i) => { const { x, y } = toXY(pt.lat, pt.lon); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
            ctx.stroke();
        }
        function drawTrail() {
            if (trail.length < 2) return;
            for (let i = 1; i < trail.length; i++) {
                const a = trail[i - 1], b = trail[i];
                let color = "#9ca3af";
                if (b.state === "clear") color = "#22c55e";
                if (b.state === "warn") color = "#facc15";
                if (b.state === "danger") color = "#ef4444";
                ctx.strokeStyle = color; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            }
        }
        function drawMarkers() {
            markers.forEach(m => {
                const { x, y } = toXY(m.lat, m.lon);
                let markerColor = "#ef4444";
                if (m.state === "warn") markerColor = "#facc15";
                if (m.state === "clear") markerColor = "#22c55e";
                ctx.fillStyle = markerColor;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        function drawDrone() {
            const { x, y } = toXY(drone.lat, drone.lon);
            ctx.save(); ctx.translate(x, y); ctx.rotate(-drone.heading);
            ctx.fillStyle = "#10b981"; ctx.beginPath(); ctx.moveTo(12, 0); ctx.lineTo(-10, 7); ctx.lineTo(-10, -7); ctx.closePath(); ctx.fill(); ctx.restore();
        }
        function render() {
            drawGrid();
            redrawStoredRoute();
            drawTrail();
            drawRoute();
            drawMarkers();
            drawDrone();
        }

        function update(dt) {
            if (!running || waypoints.length === 0) return;
            const target = waypoints[drone.targetIdx];
            const { x: tx, y: ty } = toXY(target.lat, target.lon);
            const { x: dx, y: dy } = toXY(drone.lat, drone.lon);
            const vecX = tx - dx, vecY = ty - dy;
            const dist = Math.hypot(vecX, vecY);
            if (dist < 2) {
                waypoints.splice(drone.targetIdx, 1);
                if (waypoints.length === 0) { running = false; drone.targetIdx = 0; }
                else if (drone.targetIdx >= waypoints.length) drone.targetIdx = 0;
                return;
            }
            const step = drone.speed * dt;
            const nx = dx + (vecX / dist) * step;
            const ny = dy + (vecY / dist) * step;
            drone.heading = Math.atan2(-vecY, vecX);
            const { lat, lon } = toLatLon(nx, ny);
            drone.lat = lat; drone.lon = lon;

            trail.push({ x: nx, y: ny, state: lastThreatState });
            if (trail.length > 3000) trail.shift();

            // логіка безпеки: якщо поруч патч з threatState, ставимо warn/danger
            let nearbyThreat = null;
            samplePatches.forEach(p => {
                const dyM = (p.lat - drone.lat) * mPerLat;
                const dxM = (p.lon - drone.lon) * mPerLon;
                const d = Math.hypot(dxM, dyM);
                if (d < 25 && p.threatState) {
                    if (p.threatState === "danger") nearbyThreat = "danger";
                    else if (p.threatState === "warn" && nearbyThreat !== "danger") nearbyThreat = "warn";
                }
                if (d < 25 && !p.processed && !pendingDetection) {
                    runDetectionOnPatch(p, { mode: modeSelect.value, threshold: thrInput.value });
                }
            });
            if (nearbyThreat) { lastThreatState = nearbyThreat; lastThreatTs = Date.now(); }
            else if (Date.now() - lastThreatTs > 5000) { lastThreatState = "clear"; }
        }

        let last = performance.now();
        function loop(now) { const dt = Math.min(0.05, (now - last) / 1000); last = now; update(dt); render(); requestAnimationFrame(loop); }
        requestAnimationFrame(loop);

        async function runDetectionOnPatch(patch, opts = {}) {
            if (pendingDetection) return;
            pendingDetection = true;
            detectionLog.textContent = `Сканування ${patch.label}...`;
            lastPatchThumb.innerHTML = "";
            try {
                const blob = await fetchImageBlob(patch.url);
                const formData = new FormData();
                formData.append("file", blob, `${patch.label || "patch"}.jpg`);
                formData.append("mode", opts.mode || "ensemble");
                formData.append("threshold", opts.threshold || "0.4");
                formData.append("draw_all", "false");
                const res = await fetch("/api/detect", { method: "POST", body: formData });
                if (!res.ok) { const t = await res.text(); throw new Error(t || `HTTP ${res.status}`); }
                const data = await res.json();
                const preds = data.predictions?.ensemble || data.predictions?.ssd || data.predictions?.yolo || [];
                const maxScore = preds.length ? Math.max(...preds.map(b => b[4] || 0)) : 0;
                const thr = parseFloat(opts.threshold || "0.4");
                const dangerCutoff = Math.min(1, thr + 0.15); // clamp so high thresholds still work
                let threatState = "clear";
                if (preds.length) {
                    threatState = maxScore >= dangerCutoff ? "danger" : "warn";
                    addMarker(patch.lat, patch.lon, `${patch.label || "Патч"} (${preds.length})`, threatState);
                    markRecentTrailDanger(220);
                    detectionLog.innerHTML = `<span class="badge bg-${threatState === "danger" ? "danger" : "warning text-dark"}">Підозра</span> ${patch.label} | боксів: ${preds.length} | max score: ${maxScore.toFixed(2)} | danger≥${dangerCutoff.toFixed(2)}`;
                } else {
                    detectionLog.innerHTML = `<span class="badge bg-success">Чисто</span> ${patch.label}`;
                }
                lastThreatState = threatState; lastThreatTs = Date.now(); patch.threatState = threatState;
                lastPatchThumb.innerHTML = `
                    <div class="mt-2">
                        <div class="small text-muted">Result with boxes</div>
                        <img class="thumb" src="${data.image_url}" alt="${patch.label} result">
                    </div>`;
                patch.processed = true;
            } catch (err) {
                detectionLog.innerHTML = `<span class="badge bg-warning text-dark">Помилка</span> ${err.message}`;
                lastThreatState = "warn"; lastThreatTs = Date.now();
                patch.threatState = patch.threatState || "warn";
            } finally { pendingDetection = false; }
        }

        document.getElementById("btnPlay").onclick = () => { running = true; };
        document.getElementById("btnPause").onclick = () => { running = false; };
        document.getElementById("btnManualRoute").onclick = () => {
            manualMode = true;
            resetRoute();
            running = false;
            lastThreatState = "clear";
            detectionLog.textContent = "Маршрут очищено. Додайте нові точки кліком по карті.";
        };
        document.getElementById("btnAddHome").onclick = () => {
            manualMode = false;
            resetRoute();
            addWaypoint(origin.lat, origin.lon);
            drone.targetIdx = 0;
            running = true;
            lastThreatState = "clear";
            detectionLog.textContent = "Йдемо додому.";
        };

        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const { lat, lon } = toLatLon(e.clientX - rect.left, e.clientY - rect.top);
            addWaypoint(lat, lon);
            if (manualMode) { drone.targetIdx = 0; running = true; }
        });
        canvas.addEventListener("contextmenu", (e) => e.preventDefault());

        function buildAutoRouteFromPatches() {
            waypoints = []; storedRoute = []; trail = []; drone.targetIdx = 0;
        }

        async function loadPatchesFromApi() {
            try {
                const res = await fetch("/api/patches?count=9999");
                if (!res.ok) throw new Error("Не вдалося отримати патчі");
                const data = await res.json();
                if (data.origin) {
                    origin = data.origin;
                    ({ mPerLat, mPerLon } = metersPerDegree(origin.lat));
                    drone.lat = origin.lat; drone.lon = origin.lon;
                }
                const rawPatches = (data.patches || []).map(p => ({ ...p, processed: false, threatState: null }));
                samplePatches = placePatchesAway(rawPatches);
                buildAutoRouteFromPatches();
                running = false;
            } catch (err) {
                detectionLog.innerHTML = `<span class="badge bg-warning text-dark">Патчі</span> ${err.message}`;
                samplePatches = [];
                buildAutoRouteFromPatches();
                running = false;
            }
        }

        loadPatchesFromApi();

        function updateStatus() {
            statusBox.innerHTML = `
широта: ${drone.lat.toFixed(6)}<br>
довгота: ${drone.lon.toFixed(6)}<br>
курс: ${(drone.heading * 180 / Math.PI).toFixed(1)}°<br>
швидкість: ${drone.speed.toFixed(1)} м/с<br>
точок маршруту: ${waypoints.length} | міток: ${markers.length} | стан: ${lastThreatState}
            `;
            requestAnimationFrame(updateStatus);
        }
        updateStatus();
    </script>
</body>
</html>
