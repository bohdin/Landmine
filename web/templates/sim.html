<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Операторська панель місії</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background: linear-gradient(135deg, #f1ede6, #e3d8c7); color: #1f2933; }
        .card { background: #fffaf2; border: 1px solid #e8ddcc; box-shadow: 0 12px 28px rgba(0,0,0,0.12); }
        #mapCanvas { width: 100%; height: auto; background: #fcf6ee; border: 1px solid #e8ddcc; border-radius: 12px; }
        .chip { border-radius: 999px; padding: 2px 10px; font-size: 12px; background: #f2e5d1; display: inline-block; margin-right: 6px; color: #1f2933; }
        .btn-gradient { background: linear-gradient(120deg, #22b573, #15803d); border: none; color: #f9fafb; font-weight: 600; }
        .stepper { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        .stepper .step { flex: 1 1 120px; text-align: center; padding: 6px 10px; border-radius: 999px; border: 1px solid #e8ddcc; background: #fffaf2; font-size: 12px; }
        .stepper .step span { font-weight: 700; margin-right: 6px; }
        canvas { cursor: crosshair; }
    </style>
</head>
<body class="container py-4">
    <h1 class="mb-3 text-center">Операторська панель: планування • симуляція • ризики</h1>
    <p class="text-center text-muted">Намалюйте полігон, задайте параметри, запустіть симуляцію, обробіть детекції, побудуйте зони ризику та сформуйте уточнювальну місію.</p>
    <div class="stepper mb-3">
        <div class="step"><span>1</span>Plan</div>
        <div class="step"><span>2</span>Simulate</div>
        <div class="step"><span>3</span>Process</div>
        <div class="step"><span>4</span>Risks/Export</div>
    </div>

    <div class="row g-3">
        <div class="col-lg-7">
            <canvas id="mapCanvas" width="720" height="520"></canvas>
            <div class="small text-muted mt-2">
                Клік на полотні додає точку полігону. Подвійний клік закриває полігон. Кнопка «Очистити полігон» починає заново.
            </div>
        </div>
        <div class="col-lg-5">
            <div class="card p-3 mb-3">
                <h5>Полігон та планування</h5>
                <div class="row g-2">
                    <div class="col-6">
                        <label class="form-label small">Висота 0.4 м</label>
                        <input id="altInput" type="number" class="form-control form-control-sm" value="0.4" disabled>
                    </div>
                    <div class="col-6">
                        <label class="form-label small">Швидкість 1.0 м/с</label>
                        <input id="speedInput" type="number" class="form-control form-control-sm" value="1.0" disabled>
                    </div>
                    <div class="col-6">
                        <label class="form-label small">Крок між треками, м</label>
                        <input id="trackSpacingInput" type="number" class="form-control form-control-sm" min="1" step="0.5" value="5">
                    </div>
                    <div class="col-6">
                        <label class="form-label small">Крок waypoint, м</label>
                        <input id="waypointStepInput" type="number" class="form-control form-control-sm" min="1" step="0.5" value="2">
                    </div>
                    <div class="col-6">
                        <label class="form-label small">Крок захоплення, м</label>
                        <input id="captureEveryInput" type="number" class="form-control form-control-sm" min="1" step="0.5" value="2">
                    </div>
                </div>
                <div class="d-flex gap-2 mt-3 flex-wrap">
                    <button id="createMissionBtn" class="btn btn-gradient btn-sm">Створити місію</button>
                    <button id="clearPolygonBtn" class="btn btn-outline-light btn-sm">Очистити полігон</button>
                </div>
                <div class="mt-2 small text-muted">Маршрут покриття (lawnmower) буде побудовано автоматично всередині полігону.</div>
            </div>

            <div class="card p-3 mb-3">
                <h5>AI налаштування</h5>
                <div class="row g-2">
                    <div class="col-6">
                        <label class="form-label small">Модель</label>
                        <select id="modelSelect" class="form-select form-select-sm">
                            <option value="ssd">SSD</option>
                            <option value="yolo">YOLO</option>
                            <option selected value="ensemble">Ensemble (WBF)</option>
                        </select>
                    </div>
                    <div class="col-6">
                        <label class="form-label small">Поріг</label>
                        <input id="thresholdInput" type="range" class="form-range" min="0" max="1" step="0.01" value="0.4">
                        <div class="text-muted small">Значення: <span id="thresholdValue">0.40</span></div>
                    </div>
                </div>
                <div class="form-check mt-2">
                    <input id="drawAllBox" class="form-check-input" type="checkbox" value="true">
                    <label class="form-check-label small" for="drawAllBox">Показати бокси всіх моделей</label>
                </div>
                <div class="mt-2 small text-muted">Налаштування застосовуються до simulate/process.</div>
            </div>

            <div class="card p-3 mb-3">
                <h5>Хід місії</h5>
                <div class="d-flex gap-2 flex-wrap">
                    <button id="simulateBtn" class="btn btn-primary btn-sm" disabled>Симулювати</button>
                    <button id="processBtn" class="btn btn-warning btn-sm" disabled>Обробити</button>
                    <button id="riskBtn" class="btn btn-outline-info btn-sm" disabled>Ризики/Експорт</button>
                </div>
                <div id="simStatus" class="mt-2 small text-warning"></div>
                <div class="mt-3 small" id="statusBox">Немає активної місії.</div>
                <div class="mt-2 small text-muted" id="exportBox"></div>
                <div id="detectionInfo" class="small mt-2"></div>
            </div>

            <div class="card p-3">
                <h5>Зони ризику</h5>
                <div class="row g-2 align-items-end mb-2">
                    <div class="col-6">
                        <label class="form-label small">Min score</label>
                        <input id="minScoreInput" type="range" class="form-range" min="0" max="1" step="0.05" value="0">
                        <div class="text-muted small">>= <span id="minScoreValue">0.00</span></div>
                    </div>
                    <div class="col-6">
                        <label class="form-label small">Sort</label>
                        <select id="sortZonesSelect" class="form-select form-select-sm">
                            <option value="score_desc">Score (desc)</option>
                            <option value="score_asc">Score (asc)</option>
                            <option value="detections_desc">Detections (desc)</option>
                        </select>
                    </div>
                </div>
                <div id="zonesList" class="small text-muted">Результати з'являться після обробки.</div>
                <div class="mt-2">
                    <button id="refineBtn" class="btn btn-outline-success btn-sm" disabled>Уточнити місію</button>
                </div>
            </div>

            <div class="card p-3 mt-3">
                <h5>Звіт місії</h5>
                <div id="reportBox" class="small text-muted">Звіт з'явиться після process.</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("mapCanvas");
        const ctx = canvas.getContext("2d");
        let polygonPoints = [];
        let routePoints = [];
        let riskZones = [];
        let displayZones = [];
        let minePoints = [];
        let playbackTrail = [];
        let playbackIdx = 0;
        let playbackTimer = null;
        let showRoute = true;
        let missionId = null;
        let lastRunId = null;
        let origin = { lat: 48.5000, lon: 32.2500 };
        let mPerLat = 0, mPerLon = 0;
        let zoom = 1.6; // visual zoom factor to make everything larger on canvas

        function metersPerDegree(latDeg) {
            const latRad = latDeg * Math.PI / 180;
            const mPerLatVal = 111132.954 - 559.822 * Math.cos(2 * latRad) + 1.175 * Math.cos(4 * latRad);
            const mPerLonVal = (Math.PI / 180) * 6367449 * Math.cos(latRad);
            return { mPerLat: mPerLatVal, mPerLon: mPerLonVal };
        }
        function updateMeters() {
            ({ mPerLat, mPerLon } = metersPerDegree(origin.lat));
        }
        updateMeters();

        function toXY(lat, lon) {
            const dx = (lon - origin.lon) * mPerLon * zoom;
            const dy = (lat - origin.lat) * mPerLat * zoom;
            return { x: canvas.width / 2 + dx, y: canvas.height / 2 - dy };
        }
        function toLatLon(x, y) {
            const dx = (x - canvas.width / 2) / zoom;
            const dy = (canvas.height / 2 - y) / zoom;
            return { lat: origin.lat + dy / mPerLat, lon: origin.lon + dx / mPerLon };
        }

        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#1f2937";
            ctx.lineWidth = 1;
            const step = 80 * zoom;
            for (let x = 0; x < canvas.width; x += step) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += step) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }

        function drawPolygon() {
            if (polygonPoints.length < 2) return;
            ctx.strokeStyle = "#38bdf8";
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            polygonPoints.forEach((p, idx) => {
                const { x, y } = toXY(p.lat, p.lon);
                if (idx === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.stroke();
            polygonPoints.forEach(p => {
                const { x, y } = toXY(p.lat, p.lon);
                ctx.fillStyle = "#38bdf8";
                ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }

        function drawRoute() {
            if (!showRoute) return;
            if (routePoints.length < 2) return;
            ctx.strokeStyle = "#22b573";
            ctx.lineWidth = 3;
            ctx.beginPath();
            routePoints.forEach((p, idx) => {
                const { x, y } = toXY(p[0], p[1]);
                if (idx === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
        }

        function drawWaypoints() {
            if (!showRoute) return;
            if (routePoints.length < 2) return;
            const stride = Math.max(1, Math.ceil(routePoints.length / 120));
            ctx.fillStyle = "#16a34a";
            for (let i = 0; i < routePoints.length; i += stride) {
                const { x, y } = toXY(routePoints[i][0], routePoints[i][1]);
                ctx.beginPath(); ctx.arc(x, y, 2.5, 0, Math.PI * 2); ctx.fill();
            }
        }

        function drawPlayback() {
            if (!playbackTrail.length) return;
            ctx.strokeStyle = "#f97316";
            ctx.lineWidth = 4;
            ctx.beginPath();
            playbackTrail.slice(0, playbackIdx).forEach((p, idx) => {
                const { x, y } = toXY(p.lat, p.lon);
                if (idx === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();
            const current = playbackTrail[Math.min(playbackIdx, playbackTrail.length - 1)];
            if (current) {
                const { x, y } = toXY(current.lat, current.lon);
                ctx.fillStyle = "#f97316";
                ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI * 2); ctx.fill();
            }
        }

        function drawRiskZones() {
            displayZones.forEach(zone => {
                ctx.fillStyle = "rgba(239, 68, 68, 0.18)";
                ctx.strokeStyle = "#ef4444";
                ctx.lineWidth = 2;
                ctx.beginPath();
                zone.geometry.forEach((pt, idx) => {
                    const { x, y } = toXY(pt[0], pt[1]);
                    if (idx === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                const { x, y } = toXY(zone.center_lat, zone.center_lon);
                ctx.fillStyle = "#ef4444";
                ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fill();
            });
        }

        function drawMines() {
            if (!minePoints.length) return;
            ctx.fillStyle = "#111827";
            minePoints.forEach(m => {
                const { x, y } = toXY(m.lat, m.lon);
                ctx.beginPath(); ctx.arc(x, y, 3.5, 0, Math.PI * 2); ctx.fill();
            });
        }

        function drawLegend() {
            const legendX = 12;
            const legendY = 12;
            const items = [
                { label: "Polygon", color: "#38bdf8" },
                { label: "Route", color: "#22b573" },
                { label: "Detections", color: "#f97316" },
                { label: "Risk zones", color: "#ef4444" },
            ];
            const lineHeight = 14;
            const boxWidth = 170;
            const boxHeight = (items.length + 1) * lineHeight + 10;

            ctx.save();
            ctx.fillStyle = "rgba(255, 250, 242, 0.9)";
            ctx.strokeStyle = "#e8ddcc";
            ctx.lineWidth = 1;
            ctx.fillRect(legendX, legendY, boxWidth, boxHeight);
            ctx.strokeRect(legendX, legendY, boxWidth, boxHeight);

            ctx.font = "12px sans-serif";
            items.forEach((item, idx) => {
                const y = legendY + 18 + idx * lineHeight;
                ctx.fillStyle = item.color;
                ctx.fillRect(legendX + 8, y - 8, 12, 4);
                ctx.fillStyle = "#1f2933";
                ctx.fillText(item.label, legendX + 28, y - 2);
            });
            ctx.fillStyle = "#6b7280";
            ctx.fillText("Grid: 80 m", legendX + 8, legendY + boxHeight - 6);
            ctx.restore();
        }

        function render() {
            drawGrid();
            // draw only outline to keep drone visible
            drawPolygon();
            drawRoute();
            drawWaypoints();
            drawRiskZones();
            drawMines();
            drawPlayback();
            drawLegend();
        }
        render();

        function closePolygon() {
            if (polygonPoints.length > 2) {
                origin = polygonPoints[0];
                updateMeters();
                render();
            }
        }

        canvas.addEventListener("click", (e) => {
            const rect = canvas.getBoundingClientRect();
            const { lat, lon } = toLatLon(e.clientX - rect.left, e.clientY - rect.top);
            polygonPoints.push({ lat, lon });
            render();
        });
        canvas.addEventListener("dblclick", (e) => {
            closePolygon();
        });

        document.getElementById("clearPolygonBtn").onclick = () => {
            polygonPoints = [];
            routePoints = [];
            riskZones = [];
            displayZones = [];
            minePoints = [];
            missionId = null;
            lastRunId = null;
            statusBox.textContent = "Полігон очищено. Додайте нові точки.";
            exportBox.textContent = "";
            detectionInfo.innerHTML = "";
            reportBox.textContent = "Звіт з'явиться після process.";
            simStatus.textContent = "";
            setButtons();
            render();
        };

        const statusBox = document.getElementById("statusBox");
        const exportBox = document.getElementById("exportBox");
        const zonesList = document.getElementById("zonesList");
        const simStatus = document.getElementById("simStatus");
        const reportBox = document.getElementById("reportBox");
        const detectionInfo = document.getElementById("detectionInfo");
        const modelSelect = document.getElementById("modelSelect");
        const thresholdInput = document.getElementById("thresholdInput");
        const thresholdValue = document.getElementById("thresholdValue");
        const drawAllBox = document.getElementById("drawAllBox");
        const minScoreInput = document.getElementById("minScoreInput");
        const minScoreValue = document.getElementById("minScoreValue");
        const sortZonesSelect = document.getElementById("sortZonesSelect");

        thresholdInput.addEventListener("input", () => {
            thresholdValue.textContent = Number(thresholdInput.value).toFixed(2);
        });
        minScoreInput.addEventListener("input", () => {
            minScoreValue.textContent = Number(minScoreInput.value).toFixed(2);
            applyZoneFilters();
        });
        sortZonesSelect.addEventListener("change", () => {
            applyZoneFilters();
        });
        thresholdValue.textContent = Number(thresholdInput.value).toFixed(2);
        minScoreValue.textContent = Number(minScoreInput.value).toFixed(2);

        function setButtons() {
            const hasMission = !!missionId;
            document.getElementById("simulateBtn").disabled = !hasMission;
            document.getElementById("processBtn").disabled = !hasMission;
            document.getElementById("riskBtn").disabled = !hasMission;
            document.getElementById("refineBtn").disabled = !hasMission;
        }
        setButtons();

        function sampleTrail(trail, limit = 120) {
            if (!trail || trail.length <= limit) return trail || [];
            const step = Math.max(1, Math.floor(trail.length / limit));
            const sampled = [];
            for (let i = 0; i < trail.length; i += step) {
                sampled.push(trail[i]);
            }
            if (sampled[sampled.length - 1] !== trail[trail.length - 1]) {
                sampled.push(trail[trail.length - 1]);
            }
            return sampled;
        }

        function startPlayback(trail, labelPrefix) {
            playbackTrail = sampleTrail(trail || [], 120);
            playbackIdx = 0;
            if (playbackTimer) {
                clearInterval(playbackTimer);
                playbackTimer = null;
            }
            if (!playbackTrail.length) {
                return;
            }
            simStatus.textContent = `${labelPrefix} ${playbackIdx}/${playbackTrail.length}`;
            playbackTimer = setInterval(() => {
                playbackIdx = Math.min(playbackIdx + 1, playbackTrail.length);
                simStatus.textContent = `${labelPrefix} ${playbackIdx}/${playbackTrail.length}`;
                render();
                if (playbackIdx >= playbackTrail.length) {
                    clearInterval(playbackTimer);
                    playbackTimer = null;
                }
            }, 80);
        }

        function clampScore(score) {
            if (!Number.isFinite(score)) return 0;
            return Math.max(0, Math.min(1, score));
        }

        function riskLabel(score) {
            if (score >= 0.8) return "DANGER";
            if (score >= 0.5) return "WARN";
            return "SAFE";
        }

        function riskClass(label) {
            if (label === "DANGER") return "bg-danger";
            if (label === "WARN") return "bg-warning";
            return "bg-success";
        }

        function riskBadge(score) {
            const safeScore = clampScore(score);
            const label = riskLabel(safeScore);
            return `<span class="badge ${riskClass(label)}">${label}</span> <span class="small text-muted">${safeScore.toFixed(2)}</span>`;
        }

        function riskProgress(score) {
            const safeScore = clampScore(score);
            const label = riskLabel(safeScore);
            const pct = Math.round(safeScore * 100);
            return `<div class="progress mt-1" style="height:6px;"><div class="progress-bar ${riskClass(label)}" style="width:${pct}%"></div></div>`;
        }

        function riskScoreFromPayload(payload) {
            if (!payload) return 0;
            if (payload.priority_zone && Number.isFinite(payload.priority_zone.score)) {
                return clampScore(payload.priority_zone.score);
            }
            const level = String(payload.risk_level || "").toLowerCase();
            if (level === "danger") return 0.85;
            if (level === "warn") return 0.6;
            if (level === "clear") return 0.2;
            return 0;
        }

        function normalizeExportHref(path) {
            if (!path) return "#";
            if (path.startsWith("/")) return path;
            return `/${path}`;
        }

        function renderExports(exports) {
            if (!exports) {
                exportBox.textContent = "";
                return;
            }
            const entries = [
                { label: "GeoJSON", path: exports.geojson },
                { label: "CSV", path: exports.csv },
                { label: "PDF", path: exports.pdf },
            ];
            const buttons = entries.map(e => `
                <a class="btn btn-outline-dark btn-sm me-2 mb-2" href="${normalizeExportHref(e.path)}" download>Download ${e.label}</a>
            `).join("");
            const details = `
                <details class="mt-2">
                    <summary class="small">Technical details</summary>
                    <div class="small text-muted mt-1">
                        ${entries.map(e => `${e.label}: <code>${e.path}</code>`).join("<br>")}
                    </div>
                </details>`;
            exportBox.innerHTML = `<div class="d-flex flex-wrap">${buttons}</div>${details}`;
        }

        function updateZonesList(zones) {
            if (!zones.length) {
                zonesList.textContent = "Немає зон ризику для відображення.";
                return;
            }
            zonesList.innerHTML = zones.map(z => {
                const score = clampScore(z.score);
                return `
                    <div class="mb-2">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="chip">#${z.id}</div>
                            <div>${riskBadge(score)}</div>
                        </div>
                        ${riskProgress(score)}
                        <div class="small text-muted">detections ${z.detections_count}</div>
                    </div>
                `;
            }).join("");
        }

        function applyZoneFilters() {
            const minScore = parseFloat(minScoreInput.value || "0");
            const sortMode = sortZonesSelect.value;
            displayZones = (riskZones || []).filter(z => z.score >= minScore);
            if (sortMode === "score_asc") {
                displayZones.sort((a, b) => a.score - b.score);
            } else if (sortMode === "detections_desc") {
                displayZones.sort((a, b) => b.detections_count - a.detections_count);
            } else {
                displayZones.sort((a, b) => b.score - a.score);
            }
            updateZonesList(displayZones);
            render();
        }

        function setRiskZones(zones) {
            riskZones = zones || [];
            showRoute = false;
            playbackTrail = [];
            playbackIdx = 0;
            applyZoneFilters();
        }

        function renderReport(payload) {
            if (!payload) {
                reportBox.textContent = "Немає даних для звіту.";
                return;
            }
            const riskLevel = payload.risk_level || "n/a";
            const quality = payload.data_quality || {};
            const recs = payload.recommendations || [];
            const priority = payload.priority_zone;
            const riskScore = riskScoreFromPayload(payload);
            let html = `
                <div class="d-flex align-items-center gap-2">
                    <strong>Risk:</strong> ${riskBadge(riskScore)}
                </div>
                ${riskProgress(riskScore)}
                <div class="small text-muted">level: ${riskLevel}</div>`;
            if (priority) {
                const pScore = clampScore(priority.score);
                html += `<div class="mt-2">Priority zone: #${priority.id} ${riskBadge(pScore)}</div>`;
            }
            if (quality.status) {
                html += `<div>Data quality: ${quality.status} (frames ${quality.frames}, telemetry ${quality.telemetry}, metal ${quality.metal_events})</div>`;
            }
            if (recs.length) {
                html += "<div class=\"mt-1\"><strong>Recommendations:</strong></div><ul>";
                recs.forEach(r => { html += `<li>${r}</li>`; });
                html += "</ul>";
            }
            reportBox.innerHTML = html;
        }

        async function createMission() {
            if (polygonPoints.length < 3) {
                statusBox.textContent = "Додайте щонайменше 3 точки.";
                return;
            }
            const altitude = parseFloat(document.getElementById("altInput").value);
            const speed = parseFloat(document.getElementById("speedInput").value);
            const trackSpacing = parseFloat(document.getElementById("trackSpacingInput").value);
            const waypointStep = parseFloat(document.getElementById("waypointStepInput").value);
            const captureEvery = parseFloat(document.getElementById("captureEveryInput").value);
            const payload = {
                polygon: polygonPoints.map(p => [p.lat, p.lon, altitude]),
                altitude,
                speed,
                track_spacing_m: trackSpacing,
                waypoint_step_m: waypointStep,
                capture_every_m: captureEvery
            };
            const res = await fetch("/api/missions", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            if (!res.ok) {
                statusBox.textContent = "Помилка створення місії.";
                return;
            }
            const data = await res.json();
            missionId = data.id;
            routePoints = data.route;
            minePoints = [];
            statusBox.innerHTML = `Місія створена: <span class="chip">${missionId}</span> Точок маршруту: ${routePoints.length}. Натисніть "Симулювати" для запуску.`;
            setButtons();
            render();
        }

        async function simulateMission() {
            if (!missionId) return;
            simStatus.innerHTML = `<span class="spinner-border spinner-border-sm text-warning"></span> Симуляція триває...`;
            statusBox.textContent = "Симуляція запущена...";
            const res = await fetch(`/api/missions/${missionId}/simulate`, { method: "POST" });
            if (!res.ok) { statusBox.textContent = "Помилка симуляції"; simStatus.textContent = "❌ Помилка симуляції"; return; }
            const data = await res.json();
            lastRunId = data.run_id;
            simStatus.textContent = `✅ Симуляція завершена: кадрів ${data.frames}, телеметрія ${data.telemetry}, метал ${data.metal_samples}`;
            statusBox.innerHTML = `Симуляція завершена: кадрів ${data.frames}, телеметрія ${data.telemetry}, метал ${data.metal_samples}.`;
            if (data.mines) {
                minePoints = data.mines;
            }
            startPlayback(data.preview_path || [], "Симуляція програвання");
            showRoute = true;
            render();
        }

        async function processMission() {
            if (!missionId) return;
            statusBox.textContent = "Обробка детекцій...";
            const model = modelSelect.value;
            const threshold = parseFloat(thresholdInput.value);
            const res = await fetch(`/api/missions/${missionId}/process?model=${encodeURIComponent(model)}&threshold=${threshold}`, { method: "POST" });
            if (!res.ok) { statusBox.textContent = "Помилка обробки"; return; }
            const data = await res.json();
            statusBox.innerHTML = `Оброблено: детекцій ${data.detections}, зон ${data.zones}.`;
            detectionInfo.innerHTML = `Детекцій: <strong>${data.detections}</strong>, Зон ризику: <strong>${data.zones}</strong>. Експорти доступні нижче.`;
            if (data.exports) {
                renderExports(data.exports);
            }
            if (data.sample_detection && data.sample_detection.image_url) {
                const sampleRisk = clampScore(Number(data.sample_detection.risk_score || 0));
                detectionInfo.innerHTML += `
                    <div class="mt-2">
                        <div class="small text-muted">Приклад кадру після обробки</div>
                        <img src="${data.sample_detection.image_url}" class="img-fluid rounded border" alt="sample frame">
                        <div class="small">score: ${Number(data.sample_detection.score).toFixed(2)} | risk: ${riskLabel(sampleRisk)} (${sampleRisk.toFixed(2)}) | metal: ${data.sample_detection.confirmed_by_metal ? "yes" : "no"}</div>
                    </div>`;
            }
            renderReport(data);
            loadRiskZones();
        }

        async function loadRiskZones() {
            if (!missionId) return;
            const res = await fetch(`/api/missions/${missionId}/risk-map`);
            if (!res.ok) { zonesList.textContent = "Немає зон ризику."; return; }
            const data = await res.json();
            setRiskZones(data.zones || []);
            if (lastRunId) {
                exportArtifacts();
            }
            render();
        }

        async function exportArtifacts() {
            if (!missionId) return;
            const res = await fetch(`/api/missions/${missionId}/exports`);
            if (!res.ok) { exportBox.textContent = "Не вдалося зібрати експорт."; return; }
            const data = await res.json();
            renderExports(data);
        }

        async function refineMission() {
            if (!missionId) return;
            const res = await fetch(`/api/missions/${missionId}/refine`, { method: "POST" });
            if (!res.ok) { statusBox.textContent = "Не вдалося створити уточнення."; return; }
            const data = await res.json();
            missionId = data.id;
            polygonPoints = data.polygon.map(p => ({ lat: p[0], lon: p[1] }));
            routePoints = data.route;
            riskZones = [];
            displayZones = [];
            if (data.mines) {
                minePoints = data.mines;
            }
            statusBox.innerHTML = `Створено уточнену місію: <span class="chip">${missionId}</span>`;
            setButtons();
            render();
        }

        document.getElementById("createMissionBtn").onclick = createMission;
        document.getElementById("simulateBtn").onclick = simulateMission;
        document.getElementById("processBtn").onclick = processMission;
        document.getElementById("riskBtn").onclick = loadRiskZones;
        document.getElementById("refineBtn").onclick = refineMission;
    </script>
</body>
</html>
